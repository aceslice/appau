---
export interface TrackItem {
  src: string;
  title: string;
  artist?: string;
}

export interface Props {
  src?: string;
  title?: string;
  artist?: string;
  tracks?: TrackItem[];
}
const { src = "", title = "Now playing", artist = "", tracks = [] } = Astro.props as Props;
---

<!-- Original AudioBar -->
<div class="rounded-xl border border-zinc-200 bg-white/70 backdrop-blur-2xl p-3 flex items-center gap-3"
     data-audio-bar
     data-tracks={JSON.stringify(tracks.length ? tracks : (src ? [{ src, title, artist }] : []))}>
  <div class="relative w-8 h-8" data-audio-circle>
    <svg class="w-8 h-8 -rotate-90" viewBox="0 0 32 32">
      <circle cx="16" cy="16" r="14" stroke="rgb(228 228 231)" stroke-width="2" fill="none"/>
      <circle cx="16" cy="16" r="14" stroke="rgb(251 191 36)" stroke-width="2" fill="none" 
              stroke-dasharray="87.96" stroke-dashoffset="87.96" data-audio-progress 
              style="transition: stroke-dashoffset 0.1s ease"/>
    </svg>
    <button type="button" class="absolute inset-0 flex items-center justify-center text-zinc-700 hover:text-zinc-900 focus:outline-none"
            aria-label="Play"
            data-audio-toggle>
      <span class="text-xs">▶</span>
    </button>
  </div>
  <div class="min-w-0">
    <div class="text-sm font-medium text-gray-800 truncate" data-title>{tracks.length ? tracks[0].title : title}</div>
    {(tracks.length ? tracks[0].artist : artist) && <div class="text-[11px] text-gray-600 truncate" data-artist>{tracks.length ? tracks[0].artist : artist}</div>}
  </div>
  <button type="button" class="ms-auto text-zinc-600 hover:text-zinc-800 text-sm" aria-label="Next" data-next>Next ▷</button>
</div>


<script>
  const doc = document;
  {
    const btn = doc.querySelector('[data-audio-toggle]') as HTMLButtonElement | null;
    const progress = doc.querySelector('[data-audio-progress]') as HTMLDivElement | null;
    const circle = doc.querySelector('[data-audio-circle]') as HTMLDivElement | null;
    const nextBtn = doc.querySelector('[data-next]') as HTMLButtonElement | null;
    
    // No floating bar elements - using global player from Layout.astro
    
    // Playlist from attribute
    const barEl = doc.querySelector('[data-audio-bar]') as HTMLDivElement | null;
    let playlist: { src: string; title: string; artist?: string }[] = [];
    try { const raw = barEl?.getAttribute('data-tracks') || '[]'; playlist = JSON.parse(raw); } catch {}
    let currentIndex = 0;
    
    const titleEl = doc.querySelector('[data-title]') as HTMLDivElement | null;
    const artistEl = doc.querySelector('[data-artist]') as HTMLDivElement | null;

    let isPlaying = false;

    const updateBtn = (button: HTMLButtonElement | null, isPlay: boolean) => {
      if (!button) return;
      button.textContent = isPlay ? '❚❚' : '▶';
      button.setAttribute('aria-label', isPlay ? 'Pause' : 'Play');
    };

    const updateProgress = (progressEl: HTMLDivElement | null, circumference: number) => {
      if (!progressEl) return;
      // Get progress from global player
      if ((window as any).GlobalMusicPlayer && (window as any).GlobalMusicPlayer.audio) {
        const audio = (window as any).GlobalMusicPlayer.audio;
        const p = audio.duration ? (audio.currentTime / audio.duration) : 0;
        const offset = circumference * (1 - p);
        progressEl.style.strokeDashoffset = String(offset);
      }
    };

    // Floating bar functions removed - using global player from Layout.astro

     const togglePlay = () => {
       // Always delegate to global player
       if ((window as any).GlobalMusicPlayer) {
         const globalPlayer = (window as any).GlobalMusicPlayer;
         
         if (playlist.length > 0) {
           // Set up global player with our playlist
           globalPlayer.playlist = playlist;
           globalPlayer.currentIndex = currentIndex;
           const track = playlist[currentIndex];
           
           if (globalPlayer.isPlaying) {
             // If global player is playing, just pause it
             globalPlayer.togglePlay();
           } else {
             // If global player is paused, play our track
             globalPlayer.playTrack(track);
           }
         } else {
           // No playlist, just toggle global player
           globalPlayer.togglePlay();
         }
         
         // Update our local UI to match global state
         isPlaying = globalPlayer.isPlaying;
         updateBtn(btn, isPlaying);
       }
     };

     // Connect play button to toggle function
     btn?.addEventListener('click', togglePlay);

    const circleSeek = (circleEl: HTMLDivElement | null, e: MouseEvent) => {
      if (!circleEl) return;
      // Delegate seeking to global player
      if ((window as any).GlobalMusicPlayer) {
        (window as any).GlobalMusicPlayer.seek(e);
      }
    };
    circle?.addEventListener('click', (e: MouseEvent) => circleSeek(circle, e));

    const loadTrack = (index: number, autoplay = false) => {
      if (!playlist.length) return;
      currentIndex = (index + playlist.length) % playlist.length;
      const track = playlist[currentIndex];
      
      // Update titles
      if (titleEl) titleEl.textContent = track.title;
      if (artistEl) { 
        if (track.artist) { 
          artistEl.textContent = track.artist; 
          artistEl.style.display = ''; 
        } else { 
          artistEl.style.display = 'none'; 
        } 
      }
      
      updateProgress(progress, 87.96);
      updateBtn(btn, isPlaying);
    };

     const nextTrack = () => {
       if (!playlist.length) return;
       
       // Update global player
       if ((window as any).GlobalMusicPlayer) {
         const globalPlayer = (window as any).GlobalMusicPlayer;
         globalPlayer.playlist = playlist;
         globalPlayer.currentIndex = (currentIndex + 1) % playlist.length;
         const track = playlist[globalPlayer.currentIndex];
         globalPlayer.playTrack(track);
         
         // Update local state to match
         currentIndex = globalPlayer.currentIndex;
         loadTrack(currentIndex, false); // Don't autoplay, global player handles it
         isPlaying = globalPlayer.isPlaying;
         updateBtn(btn, isPlaying);
       }
     };

    nextBtn?.addEventListener('click', nextTrack);

    // No floating close button - using global player from Layout.astro

    // Set up progress update interval to sync with global player
    const progressInterval = setInterval(() => {
      updateProgress(progress, 87.96);
    }, 100);

    // Initialize
    updateBtn(btn, isPlaying);
    updateProgress(progress, 87.96);
    if (playlist.length) loadTrack(0, false);
  }
</script>


