---
export interface TrackItem {
  src: string;
  title: string;
  artist?: string;
}

export interface Props {
  src?: string;
  title?: string;
  artist?: string;
  tracks?: TrackItem[];
}
const { src = "", title = "Now playing", artist = "", tracks = [] } = Astro.props as Props;
---

<!-- Original AudioBar -->
<div class="rounded-xl border border-zinc-200 bg-white/70 backdrop-blur-2xl p-3 flex items-center gap-3"
     data-audio-bar
     data-tracks={JSON.stringify(tracks.length ? tracks : (src ? [{ src, title, artist }] : []))}>
  <div class="relative w-8 h-8" data-audio-circle>
    <svg class="w-8 h-8 -rotate-90" viewBox="0 0 32 32">
      <circle cx="16" cy="16" r="14" stroke="rgb(228 228 231)" stroke-width="2" fill="none"/>
      <circle cx="16" cy="16" r="14" stroke="rgb(251 191 36)" stroke-width="2" fill="none" 
              stroke-dasharray="87.96" stroke-dashoffset="87.96" data-audio-progress 
              style="transition: stroke-dashoffset 0.1s ease"/>
    </svg>
    <button type="button" class="absolute inset-0 flex items-center justify-center text-zinc-700 hover:text-zinc-900 focus:outline-none"
            aria-label="Play"
            data-audio-toggle>
      <span class="text-xs">▶</span>
    </button>
  </div>
  <div class="min-w-0">
    <div class="text-sm font-medium text-gray-800 truncate" data-title>{tracks.length ? tracks[0].title : title}</div>
    {(tracks.length ? tracks[0].artist : artist) && <div class="text-[11px] text-gray-600 truncate" data-artist>{tracks.length ? tracks[0].artist : artist}</div>}
  </div>
  <button type="button" class="ms-auto text-zinc-600 hover:text-zinc-800 text-sm" aria-label="Next" data-next>Next ▷</button>
  <audio src={src} preload="none" data-audio hidden></audio>
</div>

<!-- Floating Music Bar -->
<div class="fixed bottom-6 right-6 z-50 opacity-0 pointer-events-none transition-all duration-300 transform translate-y-4"
     data-floating-bar>
  <div class="rounded-full border border-indigo-200 bg-gradient-to-r from-indigo-50/95 to-purple-50/95 backdrop-blur-2xl px-4 py-3 flex items-center gap-3 shadow-lg shadow-indigo-200/30"
       data-floating-content>
    <div class="relative w-10 h-10" data-floating-circle>
      <svg class="w-10 h-10 -rotate-90" viewBox="0 0 40 40">
        <circle cx="20" cy="20" r="18" stroke="rgb(228 228 231)" stroke-width="2" fill="none"/>
        <circle cx="20" cy="20" r="18" stroke="rgb(251 191 36)" stroke-width="2" fill="none" 
                stroke-dasharray="113.1" stroke-dashoffset="113.1" data-floating-progress 
                style="transition: stroke-dashoffset 0.1s ease"/>
      </svg>
      <button type="button" class="absolute inset-0 flex items-center justify-center text-zinc-700 hover:text-zinc-900 focus:outline-none"
              aria-label="Play"
              data-floating-toggle>
        <span class="text-sm">▶</span>
      </button>
    </div>
    <div class="min-w-0">
      <div class="text-sm font-medium text-indigo-800 truncate" data-f-title>{tracks.length ? tracks[0].title : title}</div>
      {(tracks.length ? tracks[0].artist : artist) && <div class="text-[11px] text-indigo-600 truncate" data-f-artist>{tracks.length ? tracks[0].artist : artist}</div>}
    </div>
    <button type="button" class="ml-2 text-zinc-500 hover:text-zinc-700 focus:outline-none"
            aria-label="Close"
            data-floating-close>
      <span class="text-sm">×</span>
    </button>
  </div>
</div>

<script>
  const doc = document;
  {
    const audio = doc.querySelector('[data-audio]') as HTMLAudioElement | null;
    const btn = doc.querySelector('[data-audio-toggle]') as HTMLButtonElement | null;
    const progress = doc.querySelector('[data-audio-progress]') as HTMLDivElement | null;
    const circle = doc.querySelector('[data-audio-circle]') as HTMLDivElement | null;
    const nextBtn = doc.querySelector('[data-next]') as HTMLButtonElement | null;
    
    // Floating bar elements
    const floatingBar = doc.querySelector('[data-floating-bar]') as HTMLDivElement | null;
    const floatingBtn = doc.querySelector('[data-floating-toggle]') as HTMLButtonElement | null;
    const floatingProgress = doc.querySelector('[data-floating-progress]') as HTMLDivElement | null;
    const floatingCircle = doc.querySelector('[data-floating-circle]') as HTMLDivElement | null;
    const floatingClose = doc.querySelector('[data-floating-close]') as HTMLButtonElement | null;
    
    // Playlist from attribute
    const barEl = doc.querySelector('[data-audio-bar]') as HTMLDivElement | null;
    let playlist: { src: string; title: string; artist?: string }[] = [];
    try { const raw = barEl?.getAttribute('data-tracks') || '[]'; playlist = JSON.parse(raw); } catch {}
    let currentIndex = 0;
    
    const titleEl = doc.querySelector('[data-title]') as HTMLDivElement | null;
    const artistEl = doc.querySelector('[data-artist]') as HTMLDivElement | null;
    const fTitleEl = doc.querySelector('[data-f-title]') as HTMLDivElement | null;
    const fArtistEl = doc.querySelector('[data-f-artist]') as HTMLDivElement | null;

    let isPlaying = false;

    const updateBtn = (button: HTMLButtonElement | null, isPlay: boolean) => {
      if (!button) return;
      button.textContent = isPlay ? '❚❚' : '▶';
      button.setAttribute('aria-label', isPlay ? 'Pause' : 'Play');
    };

    const updateProgress = (progressEl: HTMLDivElement | null, circumference: number) => {
      if (!audio || !progressEl) return;
      const p = audio.duration ? (audio.currentTime / audio.duration) : 0;
      const offset = circumference * (1 - p);
      progressEl.style.strokeDashoffset = String(offset);
    };

    const showFloatingBar = () => {
      if (floatingBar) {
        floatingBar.style.opacity = '1';
        floatingBar.style.pointerEvents = 'auto';
        floatingBar.style.transform = 'translateY(0)';
      }
    };

    const hideFloatingBar = () => {
      if (floatingBar) {
        floatingBar.style.opacity = '0';
        floatingBar.style.pointerEvents = 'none';
        floatingBar.style.transform = 'translateY(1rem)';
      }
    };

    const togglePlay = () => {
      if (!audio) return;
      if (audio.paused) { 
        // Send track to global player
        if (playlist.length > 0) {
          const track = playlist[currentIndex];
          window.postMessage({ 
            type: 'PLAY_MUSIC', 
            track: { src: track.src, title: track.title, artist: track.artist }
          }, '*');
        }
        audio.play(); 
        isPlaying = true; 
        showFloatingBar();
      } else { 
        audio.pause(); 
        isPlaying = false; 
      }
      updateBtn(btn, isPlaying);
      updateBtn(floatingBtn, isPlaying);
    };

    const circleSeek = (circleEl: HTMLDivElement | null, e: MouseEvent) => {
      if (!audio || !circleEl) return;
      const rect = circleEl.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX) + Math.PI / 2;
      const normalizedAngle = (angle + Math.PI) / (2 * Math.PI);
      if (audio.duration) audio.currentTime = normalizedAngle * audio.duration;
    };
    circle?.addEventListener('click', (e: MouseEvent) => circleSeek(circle, e));
    floatingCircle?.addEventListener('click', (e: MouseEvent) => circleSeek(floatingCircle, e));

    const loadTrack = (index: number, autoplay = false) => {
      if (!audio || !playlist.length) return;
      currentIndex = (index + playlist.length) % playlist.length;
      const track = playlist[currentIndex];
      audio.src = track.src;
      
      // Update titles
      if (titleEl) titleEl.textContent = track.title;
      if (artistEl) { 
        if (track.artist) { 
          artistEl.textContent = track.artist; 
          artistEl.style.display = ''; 
        } else { 
          artistEl.style.display = 'none'; 
        } 
      }
      if (fTitleEl) fTitleEl.textContent = track.title;
      if (fArtistEl) { 
        if (track.artist) { 
          fArtistEl.textContent = track.artist; 
          fArtistEl.style.display = ''; 
        } else { 
          fArtistEl.style.display = 'none'; 
        } 
      }
      
      updateProgress(progress, 87.96);
      updateProgress(floatingProgress, 113.1);
      if (autoplay) { audio.play(); isPlaying = true; showFloatingBar(); }
      updateBtn(btn, isPlaying);
      updateBtn(floatingBtn, isPlaying);
    };

    const nextTrack = () => {
      if (!playlist.length) return;
      loadTrack(currentIndex + 1, true);
    };

    nextBtn?.addEventListener('click', nextTrack);

    floatingClose?.addEventListener('click', () => {
      if (audio) {
        audio.pause();
        isPlaying = false;
        updateBtn(btn, isPlaying);
        updateBtn(floatingBtn, isPlaying);
        hideFloatingBar();
      }
    });

    audio?.addEventListener('timeupdate', () => {
      updateProgress(progress, 87.96);
      updateProgress(floatingProgress, 113.1);
    });
    
    audio?.addEventListener('loadedmetadata', () => {
      updateProgress(progress, 87.96);
      updateProgress(floatingProgress, 113.1);
    });
    
    audio?.addEventListener('ended', () => { 
      if (playlist.length > 1) { nextTrack(); return; }
      isPlaying = false; 
      updateBtn(btn, isPlaying);
      updateBtn(floatingBtn, isPlaying);
      hideFloatingBar();
    });

    // Initialize
    updateBtn(btn, isPlaying);
    updateBtn(floatingBtn, isPlaying);
    updateProgress(progress, 87.96);
    updateProgress(floatingProgress, 113.1);
    if (playlist.length) loadTrack(0, false);
  }
</script>


